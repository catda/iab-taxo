/*aud.taxonomy definition*/
CREATE TABLE aud.taxonomy (
	taxonomy_pk int4 NOT NULL GENERATED by DEFAULT AS IDENTITY
	, taxonomy varchar(50) NOT NULL
	, start_date bpchar(8) NOT NULL
	, end_date bpchar(8) NOT NULL DEFAULT '20991231'::bpchar
	, insert_dt timestamp NOT NULL DEFAULT now()
	, CONSTRAINT pkc_taxonomy PRIMARY KEY (taxonomy_pk)
);

insert into aud.taxonomy values (1, 'IAB', 20230101, 20991231, now());

/*aud.segment_type definition*/
CREATE TABLE aud.segment_type (
	segment_type_pk int4 NOT NULL GENERATED by DEFAULT AS IDENTITY
	, taxonomy_fk int4 NOT NULL
	, segment_type varchar(50) NOT NULL
	, insert_dt timestamp NOT NULL DEFAULT now()
	, CONSTRAINT pkc_segment_type PRIMARY KEY (segment_type_pk)
	, CONSTRAINT fkc_segment_type_taxonomy FOREIGN KEY (taxonomy_fk) REFERENCES aud.taxonomy(taxonomy_pk)
);


CREATE UNIQUE INDEX uidx_segment_type_taxonomy ON aud.segment_type (taxonomy_fk,segment_type);

insert into aud.segment_type (taxonomy_fk, segment_type) values (1, 'Content v3.0');


/*SEGMENT*/
CREATE TABLE aud.segment (
	segment_pk int8 NOT NULL GENERATED BY DEFAULT AS identity (START WITH 10000 INCREMENT BY 1),
	segment_type_fk int4 NOT NULL,
	segment_parent_fk int8 not null,
	segment varchar(255) NOT NULL,
	segment_id varchar (15) null, --IAB uses alphanumeric here, to match them we shall also
	segment_parent_id varchar(15) null, 
	start_date bpchar(8) NOT NULL,
	end_date bpchar(8) NOT NULL DEFAULT '20991231'::bpchar,
	is_allowed bool NOT NULL DEFAULT true,
	is_current bool NOT NULL DEFAULT false,
	insert_dt timestamp NOT NULL DEFAULT now(),
	CONSTRAINT pkc_segment PRIMARY KEY (segment_pk),
	CONSTRAINT fkc_segment_type FOREIGN KEY (segment_type_fk) REFERENCES aud.segment_type(segment_type_pk)
);

alter table aud.segment add CONSTRAINT fkc_segment_parent FOREIGN KEY (segment_parent_fk) REFERENCES aud.segment(segment_pk);
CREATE UNIQUE INDEX uidx_segment_segment_type ON aud.segment (segment_type_fk,segment)
;



/*IAB SEGMENTS AS SEGMENTS*/
--IAB Content is self-referential (parent id = segment id)
--use the IAB Content IDs as published as the segment and parent ids to more closely associate the records for maintenance

/*
 * use formulas in sheets to create insert statements from IAB Content Taxonomy
 * insert into aud.segment (segment_type_fk, segment_parent_fk, start_date, is_allowed, is_current, segment, segment_id, segment_parent_id) values (1, 0, 20230101,true,true,'
 * =concat(concat(concat(concat(concat(CONCAT($A$1,'Content Taxonomy'!C8),"', '"),'Content Taxonomy'!A8),"', '"), if('Content Taxonomy'!B8=" ",'Content Taxonomy'!A8,'Content Taxonomy'!B8)),"');")
 * 
 */

/*
 * VIEWS TO MAKE IT NICE FOR HUMANS AND CODE
 *
 * business rules can be here so that only one change impacts us all 
 */


/*VW_IAB_CONTENT_TIER*/
--provides the deepest tier the segment name is found

create view aud.vw_iab_content_tier as
--provides the deepest tier the segment name is found
select segment 
, max(max_tier) tier
, 'select segment, max_tier, is_allowed, is_active, tier_1, tier_2, tier_3, tier_4 from aud.vw_iab_content vic where tier_' || max(max_tier) || '  = ''' || segment || ''';' query_out 
from (
	--flatten the segment recursion for people
	select s4.segment segment
	, 4 as max_tier
	from aud.segment s1
	join aud.segment s2
		on s1.segment_pk = s2.segment_parent_fk
		and s1.segment_pk != s2.segment_pk
	join aud.segment s3
		on s2.segment_pk = s3.segment_parent_fk
		and s2.segment_pk != s3.segment_pk	
	join aud.segment s4
		on s3.segment_pk = s4.segment_parent_fk
		and s3.segment_pk != s4.segment_pk
	where s4.segment_type_fk = 1
	union 
	select s3.segment segment
	, 3 as max_tier
	from aud.segment s1
	join aud.segment s2
		on s1.segment_pk = s2.segment_parent_fk
		and s1.segment_pk != s2.segment_pk
	join aud.segment s3
		on s2.segment_pk = s3.segment_parent_fk
		and s2.segment_pk != s3.segment_pk	
	where s3.segment_type_fk = 1
	union 
	select s2.segment segment
	, 2 as max_tier
	from aud.segment s1
	join aud.segment s2
		on s1.segment_pk = s2.segment_parent_fk
		and s1.segment_pk != s2.segment_pk
	where s2.segment_type_fk = 1
	union
	select s1.segment segment
	, 1 as max_tier
	from aud.segment s1
	where s1.segment_type_fk = 1
	and s1.segment_pk = s1.segment_parent_fk
	) x 
group by segment
;


/*VW_IAB_CONTENT*/

create view aud.vw_iab_content as
--this is not elegant but it is straightforward
--I'm sure I'll be embarassed by this the next time I look at it
with cte_base as (
	select s1.segment segment
	, 1 as tier--segment is its parent
	, s1.is_allowed 
	, case when to_char(now(),'YYYYMMDD') between start_date and end_date then true else false end as is_active
	, s1.segment tier_1
	, null tier_2
	, null tier_3
	, null tier_4
	from aud.segment s1
	where s1.segment_type_fk = 1 --IAB content
	and s1.segment_pk = s1.segment_parent_fk
	and s1.is_current = true
	union ALL
	select s2.segment segment
	, 2 as tier
	, case when s2.is_allowed = false or s1.is_allowed = false then false else true end as is_allowed --a child cannot be allowed if its parent is not
	, case when to_char(now(),'YYYYMMDD') between s2.start_date and s2.end_date then true else false end as is_active
	, s1.segment tier_1
	, s2.segment tier_2
	, null
	, null
	from aud.segment s1
	join aud.segment s2
		on s1.segment_pk = s2.segment_parent_fk
		and s1.segment_pk != s2.segment_pk
		--and s1.segment_type_fk = s2.segment_type_fk 
	where s2.segment_type_fk = 1
	and s2.is_current = true
	union ALL
	select s3.segment segment
	, 3 as tier
	, case when s3.is_allowed = false or s2.is_allowed = false or s1.is_allowed = false then false else true end as is_allowed
	, case when to_char(now(),'YYYYMMDD') between s3.start_date and s3.end_date then true else false end as is_active
	, s1.segment tier_1
	, s2.segment tier_2
	, s3.segment tier_3
	, null
	from aud.segment s1
	join aud.segment s2
		on s1.segment_pk = s2.segment_parent_fk
		and s1.segment_pk != s2.segment_pk
		--and s1.segment_type_fk =s2.segment_type_fk 
	join aud.segment s3
		on s2.segment_pk = s3.segment_parent_fk
		and s2.segment_pk != s3.segment_pk	
		--and s2.segment_type_fk =s3.segment_type_fk 
	where s3.segment_type_fk = 1
	and s3.is_current = true
	union ALL
	select s4.segment segment
	, 4 as tier
	, case when s4.is_allowed = false or s3.is_allowed = false or s2.is_allowed = false or s1.is_allowed = false then false else true end as is_allowed
	, case when to_char(now(),'YYYYMMDD') between s4.start_date and s4.end_date then true else false end as is_active
	, s1.segment tier_1
	, s2.segment tier_2
	, s3.segment tier_3
	, s4.segment tier_4
	from aud.segment s1
	join aud.segment s2
		on s1.segment_pk = s2.segment_parent_fk
		and s1.segment_pk != s2.segment_pk
		--and s1.segment_type_fk =s2.segment_type_fk 
	join aud.segment s3
		on s2.segment_pk = s3.segment_parent_fk
		and s2.segment_pk != s3.segment_pk	
		--and s2.segment_type_fk =s3.segment_type_fk 
	join aud.segment s4
		on s3.segment_pk = s4.segment_parent_fk
		and s3.segment_pk != s4.segment_pk
		--and s3.segment_type_fk =s4.segment_type_fk 
	where s4.segment_type_fk = 1
	and s4.is_current = true
)
--join the union to the tier view to determine the deepest record to show, otherwise its all versions and not just the deepest
select cte.segment
, cte.tier
, cte.is_allowed
, cte.is_active
, cte.tier_1
, cte.tier_2
, cte.tier_3
, cte.tier_4
from cte_base cte --creates a record for each segment with all the possible max_tier
join aud.vw_iab_content_tier vw --has the deepest tier
	on cte.segment = vw.segment
	and cte.tier = vw.tier
; 


/*VW_IAB_STR_DESCENDANTS*/

create view aud.vw_iab_content_str_descendants as
--for a segment provides a comma separated, string quoted, list of all descendents sorted alphabetically
select tier_1 segment
, 1 tier
, string_agg('''' || segment || '''', ', '::text order by segment) descendants --quote the strings, order them
from aud.vw_iab_content
where is_allowed = true --ignore segments we don't allow
group by tier_1
union
select tier_2 segment
, 2
, string_agg('''' || segment || '''', ', '::text order by segment) descendants --quote the strings, order them
from aud.vw_iab_content
where is_allowed = true --ignore segments we don't allow
group by tier_2
union
select tier_3 segment
, 3
, string_agg('''' || segment || '''', ', '::text order by segment) descendants --quote the strings, order them
from aud.vw_iab_content
where is_allowed = true --ignore segments we don't allow
group by tier_3
union
select tier_4 segment
, 4
, string_agg('''' || segment || '''', ', '::text order by segment) descendants --quote the strings, order them
from aud.vw_iab_content
where is_allowed = true --ignore segments we don't allow
group by tier_4
;


